# Optimizely Graph Client <!-- omit in toc -->
An extension of the [graphql-request](https://www.npmjs.com/package/graphql-request) package, providing the configuration and additional logic needed to connect with Optimizely Graph.

## Within this document <!-- omit in toc -->
- [1. Provided services](#1-provided-services)
- [2. Usage example](#2-usage-example)
  - [2.1. GraphQL Client](#21-graphql-client)
  - [2.2. GraphQL Client Authentication](#22-graphql-client-authentication)
    - [2.2.1. Graph Keys](#221-graph-keys)
    - [2.2.2. Token passthrough](#222-token-passthrough)
    - [2.2.3. OpenID Connect](#223-openid-connect)
    - [2.2.4. Token passthrough](#224-token-passthrough)
  - [2.3. Admin API](#23-admin-api)
- [3. Configuration](#3-configuration)
  - [3.1. Preview mode/deployments](#31-preview-modedeployments)
  - [3.2. Advanced Features](#32-advanced-features)
- [4. Routing using the `RouteResolver`](#4-routing-using-the-routeresolver)
- [5. Multi-Site using the `ChannelRepository`](#5-multi-site-using-the-channelrepository)

## 1. Provided services
The package contains the following services:
- The configuration logic, to read and validate the configuration. Supports both runtime configuration objects as well a reading from environment variables.
- The GraphQL Client, based upon [graphql-request](https://www.npmjs.com/package/graphql-request), supporting the following authentication schemes for Optimizely Graph:
  - Public access (e.g. using the Single key)
  - HMAC Signed messages
  - Basic Authentication
  - Token pass-through (for Optimizely CMS in context editing)
- A RouteResolver, which simplifies handling routes when using Optimizely CMS, using the Optimizely Graph as datasource.
- A ChannelRepository, which simplifies reading channel (website) configuration from the Optimizely CMS, using the Optimizely Graph as datasource.
- An OpenAPI Client for the administrative REST services of Optimizely Graph. This follows the [service specification](https://cg.optimizely.com/app/swagger/swagger.json) and is based upon the code generated by [openapi-typescript-codegen](https://www.npmjs.com/package/openapi-typescript-codegen) from this service specification.

## 2. Usage example
### 2.1. GraphQL Client
```typescript
// Import the library
import { gql } from 'graphql-request'
import createClient, { AuthMode } from '@remkoj/optimizely-graph-client/client'
import Router from '@remkoj/optimizely-graph-client/router'
import ChannelRepository from '@remkoj/optimizely-graph-client/channels'

// Prepare the query
const document = gql`query {
  Content {
    items {
      Name
      ContentLink {
        GuidValue
      }
      Language {
        Name
      }
    }
  }
}`

// Create an instance of the client, the configuration object may be omitted 
// when executing on Node.JS. If no configuration is provided, it will be read
// from the environment variables.
// The variable client will be of type: GraphQLClient
const client = createClient({
  single_key: "your_single_key"
})

// By default the client will always use AuthMode.Public, unless overridden by the
// second parameter of createClient. Use the updateAuthentication to change the
// authentication mode after creation
client.updateAuthentication(AuthMode.Public)

// Execute a GraphQL query, the second paramer can be used to send in variables
const result = await client.request(document)

// Use the Router to get all routes registered by Optimizely CMS
const router = new Router(client)
const allPaths = await router.getRoutes()

// Use the ChannelRepository to get all registered channels within Optimizely CMS
const channels = new ChannelRepository(client)
const allChannels = await channels.getAll()
```

### 2.2. GraphQL Client Authentication 
Optimizely Graph allows restricted content to be queried, using either of the following patterns:

* **Graph Keys**: Admin authentication using Graph Sercet Key and App Key
* **Token passthrough**: Used by CMS preview/edit mode to provide a short lived access token to query the content to be previewed/edited. [Read more](https://docs.developers.optimizely.com/platform-optimizely/v1.4.0-optimizely-graph/docs/on-page-editing-using-content-graph)
* **OpenID Connect**: Used by the frontend to pass through OpenID Connect based JWT to authorize content. [Read more](https://docs.developers.optimizely.com/platform-optimizely/v1.4.0-optimizely-graph/docs/opti-id)
* **Generic Login**: Used by the fronend to pass through the username/roles from a trusted identity provider. [Read more](https://docs.developers.optimizely.com/platform-optimizely/v1.4.0-optimizely-graph/docs/basic-auth-from-backend)

#### 2.2.1. Graph Keys
The Graph Keys authentication mechanism can be enabled by providing the App Secret and App Key as part of the configuration. Then depending on your security policy, use either:

- Basic Authentication: `client.updateAuthentication(AuthMode.Basic)`
- HMAC Authentication: `client.updateAuthentication(AuthMode.HMAC)`

HMAC provides slightly better security as it both ensures message integrity and never transmits the App Secret in a decryptable form.

#### 2.2.2. Token passthrough
This method of authentication is specific to Optimizely CMS, where the edit UI will provide a short-lived token that allows access to the content that is being edited. This only requires the Single Key to be known.

```typescript
const tokenValue: string = ''; //Your token value here
client.updateAuthentication(tokenValue)
```

#### 2.2.3. OpenID Connect
This method requires two steps, first, the client must be configured with the Turnstile Tenant ID, secondly the JWT Token of the OIDC provider must be added to the client.

```typescript
const client = createClient({
  single_key: "your_single_key",
  tenant_id: "your_turnstile_tenant_id"
})
const tokenValue: string = ''; //Your OIDC JWT Token
client.updateAuthentication(tokenValue)
```

#### 2.2.4. Token passthrough
This method works with non-OIDC compliant identity providers, but requires a trusted connection with Optimizely Graph. As such, it requires the Graph Keys to ensure that the client is authorized to pass in the username and roles directly.

The roles must be provided as a comma separated list, without spaces around the values. Both the username and roles must exactly match the roles and usernames defined in Optimizely CMS.

```typescript
const client = createClient({
  single_key: "your_single_key",
  app_key: "your_app_key",
  secret: "your_secret"
})
client.setFrontendUser({
  username: "your_username",
  roles: "list_of_roles"
})
```

### 2.3. Admin API
***Warning***: The AdminAPI of Optimizely Graph requires your App Key & Secret as it allows full management of the service. When used in a browser, take all needed steps to prevent leaking of these credentials.

```typescript
import createAdminApi from '@remkoj/optimizely-graph-client/admin'

// Create an instance of the client, the configuration object may be omitted 
// when executing on Node.JS. If no configuration is provided, it will be read
// from the environment variables.
const api = createAdminApi({
    single_key: "your single key",
    app_key: "your app key",
    secret: "your secret"
})

// Use the webhooks endpoint to list all registered webhooks
const hooks = await api.webhooks.listWebhookHandler()
```

## 3. Configuration
The following configuration options are available, the table lists both the environment variable as well as property within the configuration object.

| Environment | Configuration object | Required | Usage |
| --- | --- | --- | --- |
| `OPTIMIZELY_GRAPH_GATEWAY` | gateway | no | The endpoint for Optimizely Graph |
| `OPTIMIZELY_GRAPH_SINGLE_KEY` | single_key | yes | The key needed for public, read-only access |
| `OPTIMIZELY_GRAPH_SECRET` | secret | no | The Optimizely Graph secret for write access, this value must never be made available in a browser |
| `OPTIMIZELY_GRAPH_APP_KEY` | app_key | no | The Optimizely Graph app_key for write access, this value must never be made available in a browser |
| `OPTIMIZELY_GRAPH_TENANT_ID` | tenant_id | no | The Optimizely Graph Tenant ID.<br/><br/>*Only required when using OIDC Authentication* |
| `OPTIMIZELY_GRAPH_SCHEMA` | graph_schema | no | The Schema version of Optimizely Graph to use. This defaults to the current version, but can be set to `"new"` (`SchemaVersion.Next`) to use a next version if it has been created by Optimizely CMS. |
| `SITE_DOMAIN` | deploy_domain | no | The domain of the frontend |
| `OPTIMIZELY_CMS_URL` | dxp_url | yes | The domain where the CMS has been installed |
| `OPTIMIZELY_CMS_SCHEMA` | opti_cms_schema | no | The marker for the CMS schema version, which can be used by services and the implementation. Valid values are: `OPTI-CMS-12` and `OPTI-CMS-13`. The default value is `OPTI-CMS-13` |
| `OPTIMIZELY_GRAPH_QUERY_LOG` | query_log | no | Set to "true" to enable query output to the console |
| `OPTIMIZELY_DEBUG` | debug | no | Set to "true" to enable verbose debug output to the console |

### 3.1. Preview mode/deployments
When using a preview deployment or preview mode, the Optimizely Graph client can be used to signal this state to other parts of the application that need to use this in order to adjust the query needed to retrieve the appropriate preview content.

To leverage this capability, take these steps:

1. Switch the client to a fully authenticated mode, by providing the App Key and App Secret and then enabling an authenticated connection: `client.updateAuthentication(AuthMode.HMAC)`. <br/><br/>**WARNING:** This disables all auhtorization at Optimizely Graph, moving the authorization responsibility to the preview mode/deployment.<br/><br/>
2. Enable the preview flag for the GraphQL Client, optionally providing the changeset key to use (when a specific changeset is required): `client.enablePreview()`.

Relevant methods:
- `enablePreview(changeset?: string): IOptiGraphClient`: Enable the preview flag for this client, optionally overriding the default changeset with a specific one.
- `disablePreview(): IOptiGraphClient`: Remove the "enablePreview" flag for this client.
- `isPreviewEnabled(): boolean`: Check if the preview has been enabled.
- `getChangeset(): string | null`: Get the current changeset for this client, returns `null` when preview mode is disabled.

#### Example: Enabling preview mode <!-- omit in toc -->
```typescript
// Implement your preview mode logic here
const inPrevieMode = false;

// Create a fresh client instance, if you're using environment variables, you may omit the configuration object.
const client = createClient({
    single_key: "your single key",
    app_key: "your app key",
    secret: "your secret"
});

// Only if preview mode is active
if (inPreviewMode) {
  // Bypass Graph Authentication and allow access to all content versions
  client.updateAuthentication(AuthMode.HMAC)

  // Enable preview mode for the default changeset
  client.enablePreview()
}
```

#### Example: Checking preview mode <!-- omit in toc -->
```typescript
// We're assuming that you've received the client instance in a constant named `client`. We'r reading the current changeset from it.
const changeset = client.getChangeset();

if (changeset) {
  // preview mode is active, the changeset is a string which can be used in the where clause on the _IContent._metadata.changeset field in Optimizely Graph.
}
```

### 3.2. Advanced Features
The Optimizely Graph Client has support for a number of the feature flags in Optimizely Graph and can enable/disable those on the fly.

The following features can currently be toggled:
- **Caching *[Default: enabled]*:** Provides control over the service output cache, setting this to false will make all requests be evaluated in real time instead of being cached.
- **Stored queries *[Default: enabled]*:** This will store the query to the underlying data store, so even when the output cache is invalidated, this will prevent the query to the data store to be regenerated. **Warning**: This feature does not work with cursors, so either disable it temporary or completely if you need cursors in you queries.
- **Recursive queries *[Default: disabled]*:** When enabled it enables the execution of the `@recursive(depth: n)` directive. If compatible with the queries used, this can significantly reduce the number of queries needed to build a page.

The flags are controlled by the following instance methods & fields on the Client object:
- `updateFlags(newFlags, temporary)`: Update the flags for the instance. If there's roll-back information it will throw an Error. When temporary is enabled it will create a roll-back copy of the current flags prior to updating.
- `restoreFlags()`: Restore the flags to the stored 'roll-back' copy, if there's no roll-back copy, no action is taken and no Error will be thrown.

#### Example <!-- omit in toc -->
For server-side code, with access to environment variables, adjust according to your case.
```typescript
// Import client & create instance
import createClient from '@remkoj/optimizely-graph-client/client';
const client = createClient();

// Example: Set the default for this client to add support for recursive queries
client.updateFlags({ recursive: true });

// Example: Temporary disable the query cache to allow queries with cursor
client.updateFlags({ queryCache: false }, true);
client.request(/* arguments */) // Or use - for example - an SDK / Function generated by GraphQL-Codegen
client.restoreFlags();
```

## 4. Routing using the `RouteResolver`
Optimizely CMS has built-in routing logic to enable marketeers to easily add and remove pages and move them around. To make this work, the frontend needs to be able to:
- Resolve the route (path) for every content item
- Resolve the content item for each path
- List all paths available for a given application

The router fully supports the *preview mode* flags exposed by the Optimizely Graph Client and will filter the routes based upon the selected changeset.

This is where the RouteResolver comes in and provides these capabilites, whithout the need to write the GraphQL queries for this process.

#### Example <!-- omit in toc -->
```typescript
// Get the Router from the package
import Router from '@remkoj/optimizely-graph-client/router'

// Create a new instance, using the Optimizely Graph client
const router = new Router(client)

// Retrieve all routes from Optimizely Graph, optionally provide the
// primary application domain as first parameter.
const allPaths = await router.getRoutes()

// Retrieve route information based upon a path. Either by providing a
// path and optional domain (2nd paramter), or URL object as first
// parameter.
const routeByPath = await router.getContentInfoByPath(path, domain);

// Retieve route information based upon the unique identifiers of a
// content item.
const routeByContentId = await router.getContentInfoById(key, locale, version);

// Transform the provided route info into a ContentLink instance that
// can be used by other parts of the SDK.
const contentLink = router.routeToContentLink(routeByPath);
```

## 5. Multi-Site using the `ChannelRepository`
The Optimizely CMS is fully multi-site, multi-application and multi-language aware. To simplify working with these concepts, there's a channel repository allowing you acces to these concepts<sup>1</sup>.

To generate a custom site defintion, the repository has a static method `createDefinition`.

#### Example <!-- omit in toc -->
```typescript
import ChannelRepository from '@remkoj/optimizely-graph-client/channels'

// Read the CMS URL
const cms_url = process.env.OPTIMIZELY_CMS_URL ?? 'https://example.cms.optimizely.com';

// Create the channel
const channel = ChannelRepository.createDefinition(
  "Example project",          // The name of the site
  "http://localhost:3000",    // The primary domain of the deployment
  ["en", "en-US", "en-UK"],   // The available locales
  cms_url                     // The URL of the CMS instance - optionally provide an Optimizely Graph Client
)
```

*1. The application definitions are not available through Graph for SaaS CMS, hence the repository can only instantiated for PaaS CMS 12* 