// This file is auto-generated by @hey-api/openapi-ts

/**
 * Describes a property that can contain a reference to binary data.
 */
export type BinaryProperty = ContentTypeProperty & {
    type: 'BinaryProperty';
} & {
    imageDescriptor?: ImageDescriptor;
};

/**
 * Describes a property that can contain a boolean value.
 */
export type BooleanProperty = ContentTypeProperty & {
    type: 'BooleanProperty';
} & {
    [key: string]: never;
};

/**
 * Changesets are used to group work on several content items together.
 */
export type Changeset = {
    /**
     * The unique key of this Changeset.
     */
    key: string;
    /**
     * The source of this Changeset
     */
    source?: string;
    /**
     * The name of this Changeset.
     */
    displayName: string;
    /**
     * A timestamp indicating when this changeset was first created.
     */
    readonly created?: Date;
    /**
     * The username of the user that created this changeset.
     */
    readonly createdBy?: string;
    lastModified?: Date;
};

/**
 * Changesets are used to group work on several content items together.
 */
export type ChangesetWritable = {
    /**
     * The unique key of this Changeset.
     */
    key: string;
    /**
     * The source of this Changeset
     */
    source?: string;
    /**
     * The name of this Changeset.
     */
    displayName: string;
    lastModified?: Date;
};

/**
 * Items in an changeset that contains a link to the specific content version.
 */
export type ChangesetItem = {
    reference: ContentReference;
    /**
     * Gets/sets the changeset item category.
     */
    category?: string;
};

/**
 * Items in an changeset that contains a link to the specific content version.
 */
export type ChangesetItemWritable = {
    /**
     * Gets/sets the changeset item category.
     */
    category?: string;
};

export type ChangesetItemPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<ChangesetItem>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type ChangesetItemPageWritable = {
    [key: string]: never;
};

export type ChangesetPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<Changeset>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type ChangesetPageWritable = {
    [key: string]: never;
};

/**
 * Describes a property list item that can contain a component instance of a specific type.
 */
export type ComponentListItem = ListPropertyItem & {
    type: 'ComponentListItem';
} & {
    /**
     * The key of the ContentType that this ComponentListItem can contain.
     */
    contentType: string;
};

/**
 * Describes a property that can contain a component instance of a specific type.
 */
export type ComponentProperty = ContentTypeProperty & {
    type: 'ComponentProperty';
} & {
    /**
     * The key of the ContentType that this ComponentProperty can contain.
     */
    contentType: string;
};

/**
 * Represent a Composition behavior for a ContentType.
 */
export type CompositionBehavior = 'sectionEnabled' | 'elementEnabled';

/**
 * Represent a Composition behavior for a ContentType.
 */
export const CompositionBehavior = {
    SECTION_ENABLED: 'sectionEnabled',
    ELEMENT_ENABLED: 'elementEnabled'
} as const;

/**
 * Represent the base type of a ContentType.
 */
export type ContentBaseType = 'page' | 'component' | 'media' | 'image' | 'video' | 'folder' | 'experience' | 'section' | 'element';

/**
 * Represent the base type of a ContentType.
 */
export const ContentBaseType = {
    PAGE: 'page',
    COMPONENT: 'component',
    MEDIA: 'media',
    IMAGE: 'image',
    VIDEO: 'video',
    FOLDER: 'folder',
    EXPERIENCE: 'experience',
    SECTION: 'section',
    ELEMENT: 'element'
} as const;

/**
 * Represents a content component.
 */
export type ContentComponent = {
    /**
     * The name of the content component. If Reference is set, the name is automatically set to the name of the referenced content.
     */
    name?: string;
    /**
     * An optional display option for the content component.
     */
    displayOption?: string;
    /**
     * An optional group for the personalizable component.
     */
    segmentationGroup?: string;
    /**
     * Specifies the settings for the content component.
     */
    segments?: Array<string>;
    reference?: string;
    /**
     * The key of the content type that this is an embedded instance of.
     */
    contentType?: string;
    /**
     * Dictionary with all custom properties as specified by associated ContentType
     */
    content?: unknown;
};

/**
 * Represents a version of a content item.
 */
export type ContentItem = {
    /**
     * Properties as they are defined by corresponding component or content type.
     */
    properties?: {
        [key: string]: unknown;
    };
    /**
     * The key that identifies this content item.
     */
    readonly key: string;
    /**
     * The locale of this content instance.
     */
    readonly locale?: string;
    /**
     * The version identifier of this content instance.
     */
    readonly version?: string;
    /**
     * The content type of this content item.
     */
    readonly contentType?: string;
    /**
     * The display name of this content item.
     */
    displayName: string;
    /**
     * Indicates a time when this content was published or should be published.
     */
    published?: Date | null;
    /**
     * Indicates a time when this content expired or should expire.
     */
    expired?: Date | null;
    status?: VersionStatus;
    /**
     * Indicates a time when this content version should transition to published status. Must only be assigned when Status is set to Scheduled.
     */
    delayPublishUntil?: Date | null;
    /**
     * The key that identifies the container content that this content item belongs to.
     */
    container?: string | null;
    /**
     * The key that identifies the owner of this content. Content that is own by another content is also known as an asset.
     */
    owner?: string | null;
    /**
     * A string that represents the segment that should be used when routing or generate routes to the current content instance.
     */
    routeSegment?: string | null;
    lastModified?: Date;
    /**
     * The username of the user that made the latest modification to this content instance.
     */
    readonly lastModifiedBy?: string;
};

/**
 * Represents a version of a content item.
 */
export type ContentItemWritable = {
    /**
     * Properties as they are defined by corresponding component or content type.
     */
    properties?: {
        [key: string]: unknown;
    };
    /**
     * The display name of this content item.
     */
    displayName: string;
    /**
     * Indicates a time when this content was published or should be published.
     */
    published?: Date | null;
    /**
     * Indicates a time when this content expired or should expire.
     */
    expired?: Date | null;
    status?: VersionStatus;
    /**
     * Indicates a time when this content version should transition to published status. Must only be assigned when Status is set to Scheduled.
     */
    delayPublishUntil?: Date | null;
    /**
     * The key that identifies the container content that this content item belongs to.
     */
    container?: string | null;
    /**
     * The key that identifies the owner of this content. Content that is own by another content is also known as an asset.
     */
    owner?: string | null;
    /**
     * A string that represents the segment that should be used when routing or generate routes to the current content instance.
     */
    routeSegment?: string | null;
    lastModified?: Date;
};

/**
 * The response object for Page`1 when used ContentType are included.
 */
export type ContentItemListWithContentTypes = {
    /**
     * The content types that are used by the content items in the response.
     */
    readonly contentTypes?: Array<ContentType>;
    /**
     * The content items in this paged collection.
     */
    readonly items?: Array<ContentItem>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

/**
 * The response object for Page`1 when used ContentType are included.
 */
export type ContentItemListWithContentTypesWritable = {
    [key: string]: never;
};

export type ContentItemPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<ContentItem>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type ContentItemPageWritable = {
    [key: string]: never;
};

/**
 * The response object for ContentItem when used ContentType are included.
 */
export type ContentItemWithContentTypes = {
    /**
     * The content types that are used by the content item in the response.
     */
    readonly contentTypes?: Array<ContentType>;
    item?: ContentItem;
};

/**
 * The response object for ContentItem when used ContentType are included.
 */
export type ContentItemWithContentTypesWritable = {
    item?: ContentItemWritable;
};

/**
 * Describes a property list item that can hold a content item.
 */
export type ContentListItem = ListPropertyItem & {
    type: 'ContentListItem';
} & {
    /**
     * Specifies which content types and base types these property items are allowed to contain.
     */
    allowedTypes?: Array<string>;
    /**
     * Specifies which content types and base types these property items cannot contain.
     */
    restrictedTypes?: Array<string>;
};

/**
 * Describes information about a locale instance of a content item.
 */
export type ContentLocaleInfo = {
    /**
     * The display name of the content.
     */
    readonly displayName?: string;
    /**
     * The date and time when the first locale version for the content was created.
     */
    readonly created?: Date;
    /**
     * The username of the user that created this locale version of content.
     */
    readonly createdBy?: string;
    status?: LocaleStatus;
};

/**
 * Represents metadata about a content item.
 */
export type ContentMetadata = {
    /**
     * The key that identifies this content.
     */
    key?: string;
    /**
     * The content type of this content.
     */
    contentType?: string;
    /**
     * Set of locales that this content has been created for.
     */
    readonly locales?: {
        [key: string]: ContentLocaleInfo;
    };
    /**
     * The key that identifies the container content that this content belongs to.
     */
    container?: string | null;
    /**
     * Indicates if the content contains any content items.
     */
    readonly hasItems?: boolean;
    /**
     * The key that identifies the owner of this content. Content that is own by another content is also known as an asset.
     */
    owner?: string | null;
    /**
     * A timestamp, which if provided, indicates when this content was deleted.
     */
    readonly deleted?: Date | null;
    /**
     * The username of the user that deleted this content.
     */
    readonly deletedBy?: string | null;
};

/**
 * Represents metadata about a content item.
 */
export type ContentMetadataWritable = {
    /**
     * The key that identifies this content.
     */
    key?: string;
    /**
     * The content type of this content.
     */
    contentType?: string;
    /**
     * The key that identifies the container content that this content belongs to.
     */
    container?: string | null;
    /**
     * The key that identifies the owner of this content. Content that is own by another content is also known as an asset.
     */
    owner?: string | null;
};

export type ContentMetadataPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<ContentMetadata>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type ContentMetadataPageWritable = {
    [key: string]: never;
};

/**
 * Describes a property that can contain a content item.
 */
export type ContentProperty = ContentTypeProperty & {
    type: 'ContentProperty';
} & {
    /**
     * Specifies which content types and base types this property is allowed to contain.
     */
    allowedTypes?: Array<string>;
    /**
     * Specifies which content types and base types this property cannot contain.
     */
    restrictedTypes?: Array<string>;
};

/**
 * A reference to a specific content instance.
 */
export type ContentReference = {
    /**
     * The content key that identifies the content.
     */
    readonly key?: string;
    /**
     * The name of the content locale
     */
    readonly locale?: string;
    /**
     * The identifier of a specific version of the content.
     */
    readonly version?: string;
};

/**
 * Describes a property list item that can hold a reference to a content item.
 */
export type ContentReferenceListItem = ListPropertyItem & {
    type: 'ContentReferenceListItem';
} & {
    /**
     * Specifies which content types and base types these list items are allowed to reference.
     */
    allowedTypes?: Array<string>;
    /**
     * Specifies which content types and base types these list items cannot contain.
     */
    restrictedTypes?: Array<string>;
};

/**
 * Describes a property that can contain a reference to a content item.
 */
export type ContentReferenceProperty = ContentTypeProperty & {
    type: 'ContentReferenceProperty';
} & {
    /**
     * Specifies which content types and base types this property is allowed to reference.
     */
    allowedTypes?: Array<string>;
    /**
     * Specifies which content types and base types this property is restricted from referencing.
     */
    restrictedTypes?: Array<string>;
};

/**
 * A writable implementation of an ContentType.
 */
export type ContentType = {
    /**
     * The key that identifies this ContentType.
     */
    key: string;
    /**
     * The display name of this ContentType.
     */
    displayName?: string;
    /**
     * A description of this ContentType.
     */
    description?: string;
    baseType?: ContentBaseType;
    /**
     * A string that is used to indicate the source of this ContentType.
     */
    readonly source?: string;
    /**
     * An value that is used to when sorting ContentType instances.
     */
    sortOrder?: number;
    /**
     * Provides a set of features that content based on this ContentType supports.
     * This value is assigned based on the BaseType and cannot be modified.
     */
    features?: Array<ContentTypeFeature>;
    /**
     * Specifies how this ContentType can be used.
     */
    usage?: Array<ContentTypeUsage>;
    /**
     * Provides a set of content types that can be created in container of this type
     */
    mayContainTypes?: Array<string>;
    /**
     * Provides a set of media file extensions that this content type can handle.
     */
    mediaFileExtensions?: Array<string>;
    /**
     * Provides a set of composition behaviors specifying how this content type can be used within compositions.
     */
    compositionBehaviors?: Array<CompositionBehavior>;
    /**
     * A timestamp indicating when this ContentType was first created.
     */
    readonly created?: Date;
    /**
     * Indicates the last time this content type was modified.
     */
    readonly lastModified?: Date;
    /**
     * The username of the user that made the latest modification to this ContentType.
     */
    readonly lastModifiedBy?: string;
    /**
     * Dictionary with all custom properties of this ContentType.
     */
    properties?: {
        [key: string]: (({
            type: 'BinaryProperty';
        } & BinaryProperty) | ({
            type: 'BooleanProperty';
        } & BooleanProperty) | ({
            type: 'ComponentProperty';
        } & ComponentProperty) | ({
            type: 'ContentProperty';
        } & ContentProperty) | ({
            type: 'ContentReferenceProperty';
        } & ContentReferenceProperty) | ({
            type: 'DateTimeProperty';
        } & DateTimeProperty) | ({
            type: 'FloatProperty';
        } & FloatProperty) | ({
            type: 'IntegerProperty';
        } & IntegerProperty) | ({
            type: 'StringProperty';
        } & StringProperty) | ({
            type: 'UrlProperty';
        } & UrlProperty) | ({
            type: 'JsonStringProperty';
        } & JsonStringProperty) | ({
            type: 'ListProperty';
        } & ListProperty)) & {
            /**
             * Settings for the editor.
             */
            editorSettings?: {
                [key: string]: {
                    [key: string]: unknown;
                };
            } | null;
        };
    };
};

/**
 * A writable implementation of an ContentType.
 */
export type ContentTypeWritable = {
    /**
     * The key that identifies this ContentType.
     */
    key: string;
    /**
     * The display name of this ContentType.
     */
    displayName?: string;
    /**
     * A description of this ContentType.
     */
    description?: string;
    baseType?: ContentBaseType;
    /**
     * An value that is used to when sorting ContentType instances.
     */
    sortOrder?: number;
    /**
     * Provides a set of features that content based on this ContentType supports.
     * This value is assigned based on the BaseType and cannot be modified.
     */
    features?: Array<ContentTypeFeature>;
    /**
     * Specifies how this ContentType can be used.
     */
    usage?: Array<ContentTypeUsage>;
    /**
     * Provides a set of content types that can be created in container of this type
     */
    mayContainTypes?: Array<string>;
    /**
     * Provides a set of media file extensions that this content type can handle.
     */
    mediaFileExtensions?: Array<string>;
    /**
     * Provides a set of composition behaviors specifying how this content type can be used within compositions.
     */
    compositionBehaviors?: Array<CompositionBehavior>;
    /**
     * Dictionary with all custom properties of this ContentType.
     */
    properties?: {
        [key: string]: (({
            type: 'BinaryProperty';
        } & BinaryProperty) | ({
            type: 'BooleanProperty';
        } & BooleanProperty) | ({
            type: 'ComponentProperty';
        } & ComponentProperty) | ({
            type: 'ContentProperty';
        } & ContentProperty) | ({
            type: 'ContentReferenceProperty';
        } & ContentReferenceProperty) | ({
            type: 'DateTimeProperty';
        } & DateTimeProperty) | ({
            type: 'FloatProperty';
        } & FloatProperty) | ({
            type: 'IntegerProperty';
        } & IntegerProperty) | ({
            type: 'StringProperty';
        } & StringProperty) | ({
            type: 'UrlProperty';
        } & UrlProperty) | ({
            type: 'JsonStringProperty';
        } & JsonStringProperty) | ({
            type: 'ListProperty';
        } & ListProperty)) & {
            /**
             * Settings for the editor.
             */
            editorSettings?: {
                [key: string]: {
                    [key: string]: unknown;
                };
            } | null;
        };
    };
};

/**
 * Represent different features that a content type can have.
 */
export type ContentTypeFeature = 'localization' | 'versioning' | 'publishPeriod' | 'routing' | 'binary';

/**
 * Represent different features that a content type can have.
 */
export const ContentTypeFeature = {
    LOCALIZATION: 'localization',
    VERSIONING: 'versioning',
    PUBLISH_PERIOD: 'publishPeriod',
    ROUTING: 'routing',
    BINARY: 'binary'
} as const;

export type ContentTypePage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<ContentType>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type ContentTypePageWritable = {
    [key: string]: never;
};

/**
 * Describes a property of a ContentType in the CMS.
 */
export type ContentTypeProperty = {
    type: PropertyDataType;
    /**
     * The key of the PropertyFormat that this ContentTypeProperty is an instance of.
     */
    format?: string | null;
    /**
     * The display name of this ContentTypeProperty.
     */
    displayName?: string;
    /**
     * A description of this ContentTypeProperty.
     */
    description?: string;
    /**
     * Indicates if a property instance of this type should be localized for each locale
     * or if values are shared between all locales.
     */
    localized?: boolean;
    /**
     * Indicates if a property instance of this type must always be assigned a value.
     */
    required?: boolean;
    /**
     * A reference to the PropertyGroup that this ContentTypeProperty is part of.
     * If this value is empty, a group may be assigned by the system.
     */
    group?: string;
    /**
     * An value that is used to when sorting ContentTypeProperty instances.
     */
    sortOrder?: number;
    indexingType?: IndexingType;
    /**
     * Editor used for managing this property.
     */
    editor?: string | null;
    /**
     * Settings for the editor.
     */
    editorSettings?: {
        [key: string]: {
            [key: string]: unknown;
        };
    } | null;
};

/**
 * Represent the usage types for a ContentType.
 */
export type ContentTypeUsage = 'property' | 'instance';

/**
 * Represent the usage types for a ContentType.
 */
export const ContentTypeUsage = {
    PROPERTY: 'property',
    INSTANCE: 'instance'
} as const;

/**
 * Options for copying content.
 */
export type CopyContentOptions = {
    /**
     * Indicates if deleted content could be used as source.
     */
    allowDeleted?: boolean;
    /**
     * Optional key of the container where the copied content should be placed.
     */
    container?: string | null;
    /**
     * Optional key of the owner where the copied content should be placed.
     */
    owner?: string | null;
    /**
     * Indicates if published versions of the content should keep their published status rather than being created as a draft version at the destination.
     */
    keepPublishedStatus?: boolean;
};

/**
 * Describes a property list item that can contain a timestamp.
 */
export type DateTimeListItem = ListPropertyItem & {
    type: 'DateTimeListItem';
} & {
    /**
     * The earliest timestamp that list items of this type should be able to contain.
     */
    minimum?: Date | null;
    /**
     * The latest timestamp that list items of this type should be able to contain.
     */
    maximum?: Date | null;
};

/**
 * Describes a property that can contain a timestamp.
 */
export type DateTimeProperty = ContentTypeProperty & {
    type: 'DateTimeProperty';
} & {
    /**
     * The earliest timestamp that properties of this type should be able to contain.
     */
    minimum?: Date | null;
    /**
     * The latest timestamp that properties of this type should be able to contain.
     */
    maximum?: Date | null;
};

/**
 * Describes a setting for a display template.
 */
export type DisplaySetting = {
    /**
     * The display name of this display setting.
     */
    displayName: string;
    /**
     * The suggested editor for this display setting.
     */
    editor?: string;
    /**
     * The sort order of this display setting within the template.
     */
    sortOrder?: number;
    /**
     * The available choices for this display setting.
     */
    choices?: {
        [key: string]: DisplaySettingChoice;
    };
};

/**
 * Describes a setting for a display template.
 */
export type DisplaySettingChoice = {
    /**
     * The display name of this display setting choice.
     */
    displayName: string;
    /**
     * The sort order of this choice within the setting.
     */
    sortOrder?: number;
};

/**
 * Describes a display template that can be assigned to content.
 */
export type DisplayTemplate = {
    /**
     * The key that identifies this display template.
     */
    readonly key: string;
    /**
     * The display name of this display template.
     */
    displayName: string;
    /**
     * The optional node type this display template is valid for.
     */
    nodeType?: string | null;
    baseType?: ContentBaseType;
    /**
     * The optional key of the content type this display template is valid for.
     */
    contentType?: string | null;
    /**
     * If this is the default display template for the associated base type,
     * node type or content type.
     */
    isDefault?: boolean;
    /**
     * A timestamp indicating when this display template was first created.
     */
    readonly created?: Date;
    /**
     * The username of the user that created this display template.
     */
    readonly createdBy?: string;
    /**
     * A timestamp indicating when this display template was last modified.
     */
    readonly lastModified?: Date;
    /**
     * The username of the user that last modified this display template.
     */
    readonly lastModifiedBy?: string;
    /**
     * The available settings for this display template.
     */
    settings?: {
        [key: string]: DisplaySetting;
    };
};

/**
 * Describes a display template that can be assigned to content.
 */
export type DisplayTemplateWritable = {
    /**
     * The display name of this display template.
     */
    displayName: string;
    /**
     * The optional node type this display template is valid for.
     */
    nodeType?: string | null;
    baseType?: ContentBaseType;
    /**
     * The optional key of the content type this display template is valid for.
     */
    contentType?: string | null;
    /**
     * If this is the default display template for the associated base type,
     * node type or content type.
     */
    isDefault?: boolean;
    /**
     * The available settings for this display template.
     */
    settings?: {
        [key: string]: DisplaySetting;
    };
};

export type DisplayTemplatePage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<DisplayTemplate>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type DisplayTemplatePageWritable = {
    [key: string]: never;
};

/**
 * Enumeration settings for a property or format.
 */
export type DoubleEnumerationSettings = {
    /**
     * Enumeration values for this property or format.
     */
    values?: Array<DoubleEnumerationValue>;
};

/**
 * Describes an enumeration value.
 */
export type DoubleEnumerationValue = {
    /**
     * The display name of the value.
     */
    displayName?: string;
    /**
     * The underlying enumeration value.
     */
    value?: number;
};

/**
 * Describes a property list item that can contain a float number.
 */
export type FloatListItem = ListPropertyItem & {
    type: 'FloatListItem';
} & {
    /**
     * The minimum value that list items of this type should be able to contain.
     */
    minimum?: number | null;
    /**
     * The maximum value that list items of this type should be able to contain.
     */
    maximum?: number | null;
    enum?: DoubleEnumerationSettings;
};

/**
 * Describes a property that can contain a float number.
 */
export type FloatProperty = ContentTypeProperty & {
    type: 'FloatProperty';
} & {
    /**
     * The minimum value that properties of this type should be able to contain.
     */
    minimum?: number | null;
    /**
     * The maximum value that properties of this type should be able to contain.
     */
    maximum?: number | null;
    enum?: DoubleEnumerationSettings;
};

/**
 * Instruction for generating an alternative image from the main binary of an image content item.
 */
export type ImageDescriptor = {
    /**
     * The image width in pixels.
     */
    width?: number;
    /**
     * The image height in pixels.
     */
    height?: number;
    /**
     * Indicates if the image should be pregenerated when a new image is uploaded rather than when first requested.
     */
    pregenerated?: boolean;
};

/**
 * Represents the indexing type of a content type property.
 */
export type IndexingType = 'disabled' | 'queryable' | 'searchable';

/**
 * Represents the indexing type of a content type property.
 */
export const IndexingType = {
    DISABLED: 'disabled',
    QUERYABLE: 'queryable',
    SEARCHABLE: 'searchable'
} as const;

/**
 * Enumeration settings for a property or format.
 */
export type Int32EnumerationSettings = {
    /**
     * Enumeration values for this property or format.
     */
    values?: Array<Int32EnumerationValue>;
};

/**
 * Describes an enumeration value.
 */
export type Int32EnumerationValue = {
    /**
     * The display name of the value.
     */
    displayName?: string;
    /**
     * The underlying enumeration value.
     */
    value?: number;
};

/**
 * Describes a property list item that can contain integers.
 */
export type IntegerListItem = ListPropertyItem & {
    type: 'IntegerListItem';
} & {
    /**
     * The minimum value that list items of this type should be able to contain.
     */
    minimum?: number | null;
    /**
     * The maximum value that list items of this type should be able to contain.
     */
    maximum?: number | null;
    enum?: Int32EnumerationSettings;
};

/**
 * Describes a property that can contain an integer.
 */
export type IntegerProperty = ContentTypeProperty & {
    type: 'IntegerProperty';
} & {
    /**
     * The minimum value that properties of this type should be able to contain.
     */
    minimum?: number | null;
    /**
     * The maximum value that properties of this type should be able to contain.
     */
    maximum?: number | null;
    enum?: Int32EnumerationSettings;
};

/**
 * Describes a property that can contain a JSON value in the form of a string.
 */
export type JsonStringProperty = ContentTypeProperty & {
    type: 'JsonStringProperty';
} & {
    [key: string]: never;
};

/**
 * A property in the CMS that may hold a list of items.
 */
export type ListProperty = ContentTypeProperty & {
    type: 'ListProperty';
} & {
    /**
     * Specifies the minimum number of items in this array property.
     */
    minItems?: number | null;
    /**
     * Specifies the maximum number of items in this array property.
     */
    maxItems?: number | null;
    /**
     * Describes the list item of a ListProperty in the CMS.
     */
    items: ({
        type: 'ComponentListItem';
    } & ComponentListItem) | ({
        type: 'ContentListItem';
    } & ContentListItem) | ({
        type: 'ContentReferenceListItem';
    } & ContentReferenceListItem) | ({
        type: 'DateTimeListItem';
    } & DateTimeListItem) | ({
        type: 'FloatListItem';
    } & FloatListItem) | ({
        type: 'IntegerListItem';
    } & IntegerListItem) | ({
        type: 'StringListItem';
    } & StringListItem) | ({
        type: 'UrlListItem';
    } & UrlListItem);
};

/**
 * Describes the list item of a ListProperty in the CMS.
 */
export type ListPropertyItem = {
    type: PropertyDataType;
    /**
     * The key of the PropertyFormat that this property item is an instance of.
     */
    format?: string | null;
};

/**
 * Represent the different status values of a content locale.
 */
export type LocaleStatus = 'draft' | 'published';

/**
 * Represent the different status values of a content locale.
 */
export const LocaleStatus = {
    DRAFT: 'draft',
    PUBLISHED: 'published'
} as const;

/**
 * Represents an OAuth JSON Web Token (JWT) and
 * its expiry in seconds.
 */
export type OauthToken = {
    /**
     * Gets or sets the access token.
     */
    accessToken?: string | null;
    /**
     * Gets or sets the expiry time in seconds.
     */
    expiresIn?: number;
    /**
     * Gets or sets the token type.
     */
    tokenType?: string;
};

/**
 * Represents an OAuth error.
 */
export type OauthTokenError = {
    /**
     * Gets or sets the error.
     */
    error?: string | null;
    /**
     * Gets or sets the error description.
     */
    errorDescription?: string | null;
};

/**
 * Represents an OAuth token request.
 */
export type OauthTokenRequest = {
    /**
     * Gets or sets the grant type.
     */
    grantType?: string | null;
    /**
     * Gets or sets the client id.
     */
    clientId?: string | null;
    /**
     * Gets or sets the client secret.
     */
    clientSecret?: string | null;
    /**
     * Get or sets the subject to act as.
     */
    actAs?: string | null;
};

export type ProblemDetails = {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    readonly code?: string | null;
    readonly errors?: {
        [key: string]: Array<string>;
    } | null;
    [key: string]: unknown | (string | null) | (string | null) | (number | null) | (string | null) | (string | null) | (string | null) | ({
        [key: string]: Array<string>;
    } | null) | undefined;
};

export type ProblemDetailsWritable = {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    [key: string]: unknown | (string | null) | (string | null) | (number | null) | (string | null) | (string | null) | undefined;
};

/**
 * Represent the basic type that a PropertyFormat
 * is using for data storage and data transport.
 */
export type PropertyDataType = 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'json' | 'array' | 'component';

/**
 * Represent the basic type that a PropertyFormat
 * is using for data storage and data transport.
 */
export const PropertyDataType = {
    STRING: 'string',
    URL: 'url',
    BOOLEAN: 'boolean',
    INTEGER: 'integer',
    FLOAT: 'float',
    DATE_TIME: 'dateTime',
    CONTENT_REFERENCE: 'contentReference',
    CONTENT: 'content',
    BINARY: 'binary',
    JSON: 'json',
    ARRAY: 'array',
    COMPONENT: 'component'
} as const;

/**
 * Represent the definition of semantic property formats for content items.
 */
export type PropertyFormat = {
    /**
     * The key that identifies this PropertyFormat.
     */
    key?: string;
    dataType?: PropertyDataType;
    itemType?: PropertyDataType;
    /**
     * The name and identifier of this PropertyFormat.
     */
    displayName?: string;
    /**
     * Editor used for managing properties with this format.
     */
    editor?: string | null;
    /**
     * Indicates if this property format has been deleted.
     */
    deleted?: boolean;
    /**
     * Settings for the editor.
     */
    editorSettings?: {
        [key: string]: {
            [key: string]: unknown;
        };
    } | null;
    /**
     * Enumerations for the format.
     */
    enum?: {
        values?: Array<{
            value?: string | number | number;
            displayName?: string;
        }>;
    } | null;
};

export type PropertyFormatPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<PropertyFormat>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type PropertyFormatPageWritable = {
    [key: string]: never;
};

/**
 * Describes a property group of a ContentType in the CMS.
 */
export type PropertyGroup = {
    /**
     * The key that identifies this PropertyGroup.
     */
    readonly key: string;
    /**
     * The display name of this PropertyGroup.
     */
    displayName?: string;
    /**
     * A string that is used to indicate the source of this PropertyGroup.
     */
    readonly source?: string;
    /**
     * An value that is used to when sorting PropertyGroup instances.
     */
    sortOrder?: number;
};

/**
 * Describes a property group of a ContentType in the CMS.
 */
export type PropertyGroupWritable = {
    /**
     * The display name of this PropertyGroup.
     */
    displayName?: string;
    /**
     * An value that is used to when sorting PropertyGroup instances.
     */
    sortOrder?: number;
};

export type PropertyGroupPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<PropertyGroup>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of item in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

export type PropertyGroupPageWritable = {
    [key: string]: never;
};

/**
 * Enumeration settings for a property or format.
 */
export type StringEnumerationSettings = {
    /**
     * Enumeration values for this property or format.
     */
    values?: Array<StringEnumerationValue>;
};

/**
 * Describes an enumeration value.
 */
export type StringEnumerationValue = {
    /**
     * The display name of the value.
     */
    displayName?: string;
    /**
     * The underlying enumeration value.
     */
    value?: string;
};

/**
 * Describes a property list item that can contain a string.
 */
export type StringListItem = ListPropertyItem & {
    type: 'StringListItem';
} & {
    /**
     * The minimum string length that list items of this type should be able to contain.
     */
    minLength?: number | null;
    /**
     * The maximum string length that list items of this type should be able to contain.
     */
    maxLength?: number | null;
    /**
     * Regular expression pattern that limits what strings that list items of this type should be able to contain.
     */
    pattern?: string | null;
    enum?: StringEnumerationSettings;
};

/**
 * Describes a property that can contain strings.
 */
export type StringProperty = ContentTypeProperty & {
    type: 'StringProperty';
} & {
    /**
     * The minimum string length that properties of this type should be able to contain.
     */
    minLength?: number | null;
    /**
     * The maximum string length that properties of this type should be able to contain.
     */
    maxLength?: number | null;
    /**
     * Regular expression pattern that limits what strings that properties of this type should be able to contain.
     */
    pattern?: string | null;
    enum?: StringEnumerationSettings;
};

/**
 * Describes a property list item that can contain a URL.
 */
export type UrlListItem = ListPropertyItem & {
    type: 'UrlListItem';
} & {
    [key: string]: never;
};

/**
 * Describes a property that can contain URLs.
 */
export type UrlProperty = ContentTypeProperty & {
    type: 'UrlProperty';
} & {
    [key: string]: never;
};

/**
 * Represent the different status values of a content version.
 */
export type VersionStatus = 'draft' | 'ready' | 'published' | 'previous' | 'scheduled' | 'rejected' | 'inReview';

/**
 * Represent the different status values of a content version.
 */
export const VersionStatus = {
    DRAFT: 'draft',
    READY: 'ready',
    PUBLISHED: 'published',
    PREVIOUS: 'previous',
    SCHEDULED: 'scheduled',
    REJECTED: 'rejected',
    IN_REVIEW: 'inReview'
} as const;

export type ChangesetsListData = {
    body?: never;
    path?: never;
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/changesets';
};

export type ChangesetsListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsListError = ChangesetsListErrors[keyof ChangesetsListErrors];

export type ChangesetsListResponses = {
    /**
     * OK
     */
    200: ChangesetPage;
};

export type ChangesetsListResponse = ChangesetsListResponses[keyof ChangesetsListResponses];

export type ChangesetsCreateData = {
    /**
     * The changeset that should be created.
     */
    body: ChangesetWritable;
    path?: never;
    query?: never;
    url: '/changesets';
};

export type ChangesetsCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsCreateError = ChangesetsCreateErrors[keyof ChangesetsCreateErrors];

export type ChangesetsCreateResponses = {
    /**
     * OK
     */
    200: Changeset;
};

export type ChangesetsCreateResponse = ChangesetsCreateResponses[keyof ChangesetsCreateResponses];

export type ChangesetsDeleteData = {
    body?: never;
    path: {
        /**
         * The key of the changeset to delete.
         */
        key: string;
    };
    query?: never;
    url: '/changesets/{key}';
};

export type ChangesetsDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsDeleteError = ChangesetsDeleteErrors[keyof ChangesetsDeleteErrors];

export type ChangesetsDeleteResponses = {
    /**
     * OK
     */
    200: Changeset;
};

export type ChangesetsDeleteResponse = ChangesetsDeleteResponses[keyof ChangesetsDeleteResponses];

export type ChangesetsGetData = {
    body?: never;
    path: {
        /**
         * The key of the changeset to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/changesets/{key}';
};

export type ChangesetsGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsGetError = ChangesetsGetErrors[keyof ChangesetsGetErrors];

export type ChangesetsGetResponses = {
    /**
     * OK
     */
    200: Changeset;
};

export type ChangesetsGetResponse = ChangesetsGetResponses[keyof ChangesetsGetResponses];

export type ChangesetsPutData = {
    /**
     * The values of the created or replaced changeset.
     */
    body: ChangesetWritable;
    path: {
        /**
         * The key of the changeset to update or create.
         */
        key: string;
    };
    query?: never;
    url: '/changesets/{key}';
};

export type ChangesetsPutErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsPutError = ChangesetsPutErrors[keyof ChangesetsPutErrors];

export type ChangesetsPutResponses = {
    /**
     * OK
     */
    200: Changeset;
};

export type ChangesetsPutResponse = ChangesetsPutResponses[keyof ChangesetsPutResponses];

export type ChangesetsDeleteItemData = {
    body?: never;
    path: {
        /**
         * The changeset key
         */
        changeset: string;
        /**
         * The content key
         */
        key: string;
        /**
         * The content version
         */
        version: string;
    };
    query?: never;
    url: '/changesets/{changeset}/items/{key}/versions/{version}';
};

export type ChangesetsDeleteItemErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsDeleteItemError = ChangesetsDeleteItemErrors[keyof ChangesetsDeleteItemErrors];

export type ChangesetsDeleteItemResponses = {
    /**
     * OK
     */
    200: ChangesetItem;
};

export type ChangesetsDeleteItemResponse = ChangesetsDeleteItemResponses[keyof ChangesetsDeleteItemResponses];

export type ChangesetsGetItemData = {
    body?: never;
    path: {
        /**
         * The changeset key
         */
        changeset: string;
        /**
         * The content key
         */
        key: string;
        /**
         * The content version
         */
        version: string;
    };
    query?: never;
    url: '/changesets/{changeset}/items/{key}/versions/{version}';
};

export type ChangesetsGetItemErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsGetItemError = ChangesetsGetItemErrors[keyof ChangesetsGetItemErrors];

export type ChangesetsGetItemResponses = {
    /**
     * OK
     */
    200: ChangesetItem;
};

export type ChangesetsGetItemResponse = ChangesetsGetItemResponses[keyof ChangesetsGetItemResponses];

export type ChangesetsListItemsData = {
    body?: never;
    path: {
        /**
         * The changeset key
         */
        changeset: string;
    };
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/changesets/{changeset}/items';
};

export type ChangesetsListItemsErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsListItemsError = ChangesetsListItemsErrors[keyof ChangesetsListItemsErrors];

export type ChangesetsListItemsResponses = {
    /**
     * OK
     */
    200: ChangesetItemPage;
};

export type ChangesetsListItemsResponse = ChangesetsListItemsResponses[keyof ChangesetsListItemsResponses];

export type ChangesetsCreateItemData = {
    /**
     * The changeset item
     */
    body: ChangesetItemWritable;
    path: {
        /**
         * The changeset key
         */
        changeset: string;
    };
    query?: never;
    url: '/changesets/{changeset}/items';
};

export type ChangesetsCreateItemErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsCreateItemError = ChangesetsCreateItemErrors[keyof ChangesetsCreateItemErrors];

export type ChangesetsCreateItemResponses = {
    /**
     * OK
     */
    200: ChangesetItem;
};

export type ChangesetsCreateItemResponse = ChangesetsCreateItemResponses[keyof ChangesetsCreateItemResponses];

export type ChangesetsUpdateItemData = {
    /**
     * The changeset item
     */
    body: ChangesetItemWritable;
    path: {
        /**
         * The changeset key
         */
        changeset: string;
        /**
         * The content key
         */
        contentKey: string;
        /**
         * The content version
         */
        contentVersion: string;
    };
    query?: {
        /**
         * Indicates if a new changeset item should be created if it does not exist
         */
        allowCreate?: boolean;
    };
    url: '/changesets/{changeset}/items/{contentKey}/versions/{contentVersion}';
};

export type ChangesetsUpdateItemErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ChangesetsUpdateItemError = ChangesetsUpdateItemErrors[keyof ChangesetsUpdateItemErrors];

export type ChangesetsUpdateItemResponses = {
    /**
     * OK
     */
    200: ChangesetItem;
};

export type ChangesetsUpdateItemResponse = ChangesetsUpdateItemResponses[keyof ChangesetsUpdateItemResponses];

export type ContentCreateData = {
    /**
     * The content item that should be created.
     */
    body: ContentItemWritable;
    path?: never;
    query?: {
        /**
         * Indicates that the content validation should be ignored.
         */
        skipValidation?: boolean;
    };
    url: '/content';
};

export type ContentCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentCreateError = ContentCreateErrors[keyof ContentCreateErrors];

export type ContentCreateResponses = {
    /**
     * Created
     */
    201: ContentItemWithContentTypes;
};

export type ContentCreateResponse = ContentCreateResponses[keyof ContentCreateResponses];

export type ContentDeleteData = {
    body?: never;
    path: {
        /**
         * The key of the content item to delete.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates that the content item should be permanently deleted immediately or if it should be soft deleted first.
         */
        permanent?: boolean;
    };
    url: '/content/{key}';
};

export type ContentDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentDeleteError = ContentDeleteErrors[keyof ContentDeleteErrors];

export type ContentDeleteResponses = {
    /**
     * OK
     */
    200: ContentMetadata;
};

export type ContentDeleteResponse = ContentDeleteResponses[keyof ContentDeleteResponses];

export type ContentGetMetadataData = {
    body?: never;
    path: {
        /**
         * The key of the content to retrieve metadata for.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates that metadata for a deleted content may be returned.
         */
        allowDeleted?: boolean;
    };
    url: '/content/{key}';
};

export type ContentGetMetadataErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentGetMetadataError = ContentGetMetadataErrors[keyof ContentGetMetadataErrors];

export type ContentGetMetadataResponses = {
    /**
     * OK
     */
    200: ContentMetadata;
};

export type ContentGetMetadataResponse = ContentGetMetadataResponses[keyof ContentGetMetadataResponses];

export type ContentPatchMetadataData = {
    /**
     * The values of the content item that should be updated.
     */
    body: ContentMetadataWritable;
    path: {
        /**
         * The key of the content item to patch.
         */
        key: string;
    };
    query?: never;
    url: '/content/{key}';
};

export type ContentPatchMetadataErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentPatchMetadataError = ContentPatchMetadataErrors[keyof ContentPatchMetadataErrors];

export type ContentPatchMetadataResponses = {
    /**
     * OK
     */
    200: ContentMetadata;
};

export type ContentPatchMetadataResponse = ContentPatchMetadataResponses[keyof ContentPatchMetadataResponses];

export type ContentGetPathData = {
    body?: never;
    path: {
        /**
         * The key of the content path to retrieve.
         */
        key: string;
    };
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/content/{key}/path';
};

export type ContentGetPathErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentGetPathError = ContentGetPathErrors[keyof ContentGetPathErrors];

export type ContentGetPathResponses = {
    /**
     * OK
     */
    200: ContentMetadataPage;
};

export type ContentGetPathResponse = ContentGetPathResponses[keyof ContentGetPathResponses];

export type ContentListItemsData = {
    body?: never;
    path: {
        /**
         * The key of the content to retrieve items for.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates which content types or base types to include in the list.
         */
        contentTypes?: Array<string>;
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/content/{key}/items';
};

export type ContentListItemsErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentListItemsError = ContentListItemsErrors[keyof ContentListItemsErrors];

export type ContentListItemsResponses = {
    /**
     * OK
     */
    200: ContentMetadataPage;
};

export type ContentListItemsResponse = ContentListItemsResponses[keyof ContentListItemsResponses];

export type ContentListAssetsData = {
    body?: never;
    path: {
        /**
         * The key of the content to retrieve assets for.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates which content types or base types to include in the list.
         */
        contentTypes?: Array<string>;
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/content/{key}/assets';
};

export type ContentListAssetsErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentListAssetsError = ContentListAssetsErrors[keyof ContentListAssetsErrors];

export type ContentListAssetsResponses = {
    /**
     * OK
     */
    200: ContentMetadataPage;
};

export type ContentListAssetsResponse = ContentListAssetsResponses[keyof ContentListAssetsResponses];

export type ContentCopyData = {
    /**
     * Optional instructions for how to copy content.
     */
    body?: CopyContentOptions;
    path: {
        /**
         * The key of the content item to copy.
         */
        key: string;
    };
    query?: never;
    url: '/content/{key}:copy';
};

export type ContentCopyErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentCopyError = ContentCopyErrors[keyof ContentCopyErrors];

export type ContentCopyResponses = {
    /**
     * OK
     */
    200: ContentMetadata;
};

export type ContentCopyResponse = ContentCopyResponses[keyof ContentCopyResponses];

export type ContentUndeleteData = {
    body?: never;
    path: {
        /**
         * The key of the content item to undelete.
         */
        key: string;
    };
    query?: never;
    url: '/content/{key}:undelete';
};

export type ContentUndeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentUndeleteError = ContentUndeleteErrors[keyof ContentUndeleteErrors];

export type ContentUndeleteResponses = {
    /**
     * OK
     */
    200: ContentMetadata;
};

export type ContentUndeleteResponse = ContentUndeleteResponses[keyof ContentUndeleteResponses];

export type ContentListAllVersionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Indicates which content locales that should be listed. Use 'NEUTRAL' to include locale-neutral content.
         * Locale must be a valid IETF BCP-47 language tag.
         */
        locales?: Array<string>;
        /**
         * Indicates which status content versions must have to be listed.
         */
        statuses?: Array<VersionStatus>;
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/content/versions';
};

export type ContentListAllVersionsErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentListAllVersionsError = ContentListAllVersionsErrors[keyof ContentListAllVersionsErrors];

export type ContentListAllVersionsResponses = {
    /**
     * OK
     */
    200: ContentItemListWithContentTypes;
};

export type ContentListAllVersionsResponse = ContentListAllVersionsResponses[keyof ContentListAllVersionsResponses];

export type ContentDeleteLocaleData = {
    body?: never;
    path: {
        key: string;
    };
    query?: {
        locale?: string;
    };
    url: '/content/{key}/versions';
};

export type ContentDeleteLocaleErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentDeleteLocaleError = ContentDeleteLocaleErrors[keyof ContentDeleteLocaleErrors];

export type ContentDeleteLocaleResponses = {
    /**
     * OK
     */
    200: ContentItemWithContentTypes;
};

export type ContentDeleteLocaleResponse = ContentDeleteLocaleResponses[keyof ContentDeleteLocaleResponses];

export type ContentListVersionsData = {
    body?: never;
    path: {
        key: string;
    };
    query?: {
        /**
         * Indicates which content locales that should be listed. Use 'NEUTRAL' to include locale-neutral content.
         * Locale must be a valid IETF BCP-47 language tag.
         */
        locales?: Array<string>;
        /**
         * Indicates which status content versions must have to be listed.
         */
        statuses?: Array<VersionStatus>;
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/content/{key}/versions';
};

export type ContentListVersionsErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentListVersionsError = ContentListVersionsErrors[keyof ContentListVersionsErrors];

export type ContentListVersionsResponses = {
    /**
     * OK
     */
    200: ContentItemListWithContentTypes;
};

export type ContentListVersionsResponse = ContentListVersionsResponses[keyof ContentListVersionsResponses];

export type ContentCreateVersionData = {
    /**
     * The content version that should be created.
     */
    body: ContentItemWritable;
    path: {
        /**
         * The key of the content item for which a new content version should be created.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates that the content validation should be ignored.
         */
        skipValidation?: boolean;
    };
    url: '/content/{key}/versions';
};

export type ContentCreateVersionErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentCreateVersionError = ContentCreateVersionErrors[keyof ContentCreateVersionErrors];

export type ContentCreateVersionResponses = {
    /**
     * Created
     */
    201: ContentItemWithContentTypes;
};

export type ContentCreateVersionResponse = ContentCreateVersionResponses[keyof ContentCreateVersionResponses];

export type ContentDeleteVersionData = {
    body?: never;
    path: {
        key: string;
        version: string;
    };
    query?: never;
    url: '/content/{key}/versions/{version}';
};

export type ContentDeleteVersionErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentDeleteVersionError = ContentDeleteVersionErrors[keyof ContentDeleteVersionErrors];

export type ContentDeleteVersionResponses = {
    /**
     * OK
     */
    200: ContentItemWithContentTypes;
};

export type ContentDeleteVersionResponse = ContentDeleteVersionResponses[keyof ContentDeleteVersionResponses];

export type ContentGetVersionData = {
    body?: never;
    path: {
        key: string;
        version: string;
    };
    query?: {
        locale?: string;
    };
    url: '/content/{key}/versions/{version}';
};

export type ContentGetVersionErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentGetVersionError = ContentGetVersionErrors[keyof ContentGetVersionErrors];

export type ContentGetVersionResponses = {
    /**
     * OK
     */
    200: ContentItemWithContentTypes;
};

export type ContentGetVersionResponse = ContentGetVersionResponses[keyof ContentGetVersionResponses];

export type ContentPatchVersionData = {
    /**
     * The content information that should be updated.
     */
    body: ContentItemWritable;
    path: {
        /**
         * The key of the content item that should be updated.
         */
        key: string;
        /**
         * The version of the content that should be updated.
         */
        version: string;
    };
    query?: {
        /**
         * The locale of the content that should be updated.
         */
        locale?: string;
        /**
         * Indicates that the content validation should be ignored.
         */
        skipValidation?: boolean;
    };
    url: '/content/{key}/versions/{version}';
};

export type ContentPatchVersionErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentPatchVersionError = ContentPatchVersionErrors[keyof ContentPatchVersionErrors];

export type ContentPatchVersionResponses = {
    /**
     * OK
     */
    200: ContentItemWithContentTypes;
};

export type ContentPatchVersionResponse = ContentPatchVersionResponses[keyof ContentPatchVersionResponses];

export type ContentTypesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only include types that are available for creation under the provided container type
         */
        forContainerType?: string;
        /**
         * Indicates which sources should be included when listing content types.
         * Use All to include content types from all sources or
         * Default to include content types without a specific sources.
         */
        sources?: Array<string>;
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/contenttypes';
};

export type ContentTypesListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesListError = ContentTypesListErrors[keyof ContentTypesListErrors];

export type ContentTypesListResponses = {
    /**
     * OK
     */
    200: ContentTypePage;
};

export type ContentTypesListResponse = ContentTypesListResponses[keyof ContentTypesListResponses];

export type ContentTypesCreateData = {
    /**
     * The content type that should be created.
     */
    body: ContentTypeWritable;
    path?: never;
    query?: never;
    url: '/contenttypes';
};

export type ContentTypesCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesCreateError = ContentTypesCreateErrors[keyof ContentTypesCreateErrors];

export type ContentTypesCreateResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesCreateResponse = ContentTypesCreateResponses[keyof ContentTypesCreateResponses];

export type ContentTypesDeleteData = {
    body?: never;
    path: {
        /**
         * The key of the content type to delete.
         */
        key: string;
    };
    query?: never;
    url: '/contenttypes/{key}';
};

export type ContentTypesDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesDeleteError = ContentTypesDeleteErrors[keyof ContentTypesDeleteErrors];

export type ContentTypesDeleteResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesDeleteResponse = ContentTypesDeleteResponses[keyof ContentTypesDeleteResponses];

export type ContentTypesGetData = {
    body?: never;
    path: {
        /**
         * The key of the content type to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/contenttypes/{key}';
};

export type ContentTypesGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesGetError = ContentTypesGetErrors[keyof ContentTypesGetErrors];

export type ContentTypesGetResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesGetResponse = ContentTypesGetResponses[keyof ContentTypesGetResponses];

export type ContentTypesPatchData = {
    /**
     * The values of the content type that should be updated.
     */
    body: ContentTypeWritable;
    path: {
        /**
         * The key of the content type to patch.
         */
        key: string;
    };
    query?: {
        /**
         * Update the content type even though the changes might result in data loss.
         */
        ignoreDataLossWarnings?: boolean;
    };
    url: '/contenttypes/{key}';
};

export type ContentTypesPatchErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesPatchError = ContentTypesPatchErrors[keyof ContentTypesPatchErrors];

export type ContentTypesPatchResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesPatchResponse = ContentTypesPatchResponses[keyof ContentTypesPatchResponses];

export type ContentTypesPutData = {
    /**
     * The values of the created or replaced content type.
     */
    body: ContentTypeWritable;
    path: {
        /**
         * The key of the content type to update or create.
         */
        key: string;
    };
    query?: {
        /**
         * Update the content type even though the changes might result in data loss.
         */
        ignoreDataLossWarnings?: boolean;
    };
    url: '/contenttypes/{key}';
};

export type ContentTypesPutErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesPutError = ContentTypesPutErrors[keyof ContentTypesPutErrors];

export type ContentTypesPutResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesPutResponse = ContentTypesPutResponses[keyof ContentTypesPutResponses];

export type DisplayTemplatesListData = {
    body?: never;
    path?: never;
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/displaytemplates';
};

export type DisplayTemplatesListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesListError = DisplayTemplatesListErrors[keyof DisplayTemplatesListErrors];

export type DisplayTemplatesListResponses = {
    /**
     * OK
     */
    200: DisplayTemplatePage;
};

export type DisplayTemplatesListResponse = DisplayTemplatesListResponses[keyof DisplayTemplatesListResponses];

export type DisplayTemplatesCreateData = {
    /**
     * The display template that should be created.
     */
    body: DisplayTemplateWritable;
    path?: never;
    query?: never;
    url: '/displaytemplates';
};

export type DisplayTemplatesCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesCreateError = DisplayTemplatesCreateErrors[keyof DisplayTemplatesCreateErrors];

export type DisplayTemplatesCreateResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesCreateResponse = DisplayTemplatesCreateResponses[keyof DisplayTemplatesCreateResponses];

export type DisplayTemplatesDeleteData = {
    body?: never;
    path: {
        /**
         * The key of the display template to delete.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesDeleteError = DisplayTemplatesDeleteErrors[keyof DisplayTemplatesDeleteErrors];

export type DisplayTemplatesDeleteResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesDeleteResponse = DisplayTemplatesDeleteResponses[keyof DisplayTemplatesDeleteResponses];

export type DisplayTemplatesGetData = {
    body?: never;
    path: {
        /**
         * The key of the display template to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesGetError = DisplayTemplatesGetErrors[keyof DisplayTemplatesGetErrors];

export type DisplayTemplatesGetResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesGetResponse = DisplayTemplatesGetResponses[keyof DisplayTemplatesGetResponses];

export type DisplayTemplatesPatchData = {
    /**
     * The values of the display template that should be updated.
     */
    body: DisplayTemplateWritable;
    path: {
        /**
         * The key of the display template to patch.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesPatchErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesPatchError = DisplayTemplatesPatchErrors[keyof DisplayTemplatesPatchErrors];

export type DisplayTemplatesPatchResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesPatchResponse = DisplayTemplatesPatchResponses[keyof DisplayTemplatesPatchResponses];

export type DisplayTemplatesPutData = {
    /**
     * The values of the created or replaced display template.
     */
    body: DisplayTemplateWritable;
    path: {
        /**
         * The key of the display template to update or create.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesPutErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesPutError = DisplayTemplatesPutErrors[keyof DisplayTemplatesPutErrors];

export type DisplayTemplatesPutResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesPutResponse = DisplayTemplatesPutResponses[keyof DisplayTemplatesPutResponses];

export type OauthTokenData = {
    body: OauthTokenRequest;
    path?: never;
    query?: never;
    url: '/oauth/token';
};

export type OauthTokenErrors = {
    /**
     * Bad Request
     */
    400: OauthTokenError;
};

export type OauthTokenError2 = OauthTokenErrors[keyof OauthTokenErrors];

export type OauthTokenResponses = {
    /**
     * OK
     */
    200: OauthToken;
};

export type OauthTokenResponse = OauthTokenResponses[keyof OauthTokenResponses];

export type PropertyFormatsListData = {
    body?: never;
    path?: never;
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/propertyformats';
};

export type PropertyFormatsListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyFormatsListError = PropertyFormatsListErrors[keyof PropertyFormatsListErrors];

export type PropertyFormatsListResponses = {
    /**
     * OK
     */
    200: PropertyFormatPage;
};

export type PropertyFormatsListResponse = PropertyFormatsListResponses[keyof PropertyFormatsListResponses];

export type PropertyFormatsGetData = {
    body?: never;
    path: {
        /**
         * The key of the property format to retrieve.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates that a deleted property format may be returned.
         */
        allowDeleted?: boolean;
    };
    url: '/propertyformats/{key}';
};

export type PropertyFormatsGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyFormatsGetError = PropertyFormatsGetErrors[keyof PropertyFormatsGetErrors];

export type PropertyFormatsGetResponses = {
    /**
     * OK
     */
    200: PropertyFormat;
};

export type PropertyFormatsGetResponse = PropertyFormatsGetResponses[keyof PropertyFormatsGetResponses];

export type PropertyGroupsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Indicates which property groups sources that should be listed.
         * Use All to include groups from all sources or
         * Default to include groups without a specific sources.
         */
        sources?: Array<string>;
    };
    url: '/propertygroups';
};

export type PropertyGroupsListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsListError = PropertyGroupsListErrors[keyof PropertyGroupsListErrors];

export type PropertyGroupsListResponses = {
    /**
     * OK
     */
    200: PropertyGroupPage;
};

export type PropertyGroupsListResponse = PropertyGroupsListResponses[keyof PropertyGroupsListResponses];

export type PropertyGroupsCreateData = {
    /**
     * The property group that should be created.
     */
    body: PropertyGroupWritable;
    path?: never;
    query?: never;
    url: '/propertygroups';
};

export type PropertyGroupsCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsCreateError = PropertyGroupsCreateErrors[keyof PropertyGroupsCreateErrors];

export type PropertyGroupsCreateResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsCreateResponse = PropertyGroupsCreateResponses[keyof PropertyGroupsCreateResponses];

export type PropertyGroupsDeleteData = {
    body?: never;
    path: {
        /**
         * The key of the property group to delete.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsDeleteError = PropertyGroupsDeleteErrors[keyof PropertyGroupsDeleteErrors];

export type PropertyGroupsDeleteResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsDeleteResponse = PropertyGroupsDeleteResponses[keyof PropertyGroupsDeleteResponses];

export type PropertyGroupsGetData = {
    body?: never;
    path: {
        /**
         * The key of the property group to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsGetError = PropertyGroupsGetErrors[keyof PropertyGroupsGetErrors];

export type PropertyGroupsGetResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsGetResponse = PropertyGroupsGetResponses[keyof PropertyGroupsGetResponses];

export type PropertyGroupsPatchData = {
    /**
     * The values of the property group that should be updated.
     */
    body: PropertyGroupWritable;
    path: {
        /**
         * The key of the property group to patch.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsPatchErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsPatchError = PropertyGroupsPatchErrors[keyof PropertyGroupsPatchErrors];

export type PropertyGroupsPatchResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsPatchResponse = PropertyGroupsPatchResponses[keyof PropertyGroupsPatchResponses];

export type PropertyGroupsPutData = {
    /**
     * The values of the created or replaced property group.
     */
    body: PropertyGroupWritable;
    path: {
        /**
         * The key of the property group to update or create.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsPutErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsPutError = PropertyGroupsPutErrors[keyof PropertyGroupsPutErrors];

export type PropertyGroupsPutResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsPutResponse = PropertyGroupsPutResponses[keyof PropertyGroupsPutResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}/_cms/preview2` | (string & {});
};