// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.cms.optimizely.com/preview3' | (string & {});
};

/**
 * Describes the list item of a content type property of type 'array'.
 */
export type ArrayItem = {
    /**
     * Gets the data type for the list item property.
     */
    type?: 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'link' | 'richText' | 'json' | 'component';
    /**
     * The key of the PropertyFormat that this property item is an instance of.
     */
    format?: string | null;
    /**
     * The key of the content type that a property with 'type': 'component' may contain.
     */
    contentType?: string | null;
    /**
     * The minimum value that properties of this type should be able to contain. Value type must match the type of the array item.
     */
    minimum?: number | null | number | string;
    /**
     * The maximum value that properties of this type should be able to contain. Value type must match the type of the array item.
     */
    maximum?: number | null | number | string;
    /**
     * The minimum string length that list items of this type should be able to contain.
     */
    minLength?: number | null;
    /**
     * The maximum string length that list items of this type should be able to contain.
     */
    maxLength?: number | null;
    /**
     * Regular expression pattern that limits what strings that list items of this type should be able to contain.
     */
    pattern?: string | null;
    /**
     * A list of possible values that properties of this type should be able to contain.
     */
    enum?: Array<EnumerationValue> | null;
    /**
     * Specifies which content types and base types this property is allowed to contain.
     */
    allowedTypes?: Array<string>;
    /**
     * Specifies which content types and base types this property cannot contain.
     */
    restrictedTypes?: Array<string>;
};

/**
 * A writable implementation of an ContentType.
 */
export type ContentType = {
    /**
     * The key that identifies this ContentType.
     */
    key?: string;
    /**
     * The display name of this ContentType.
     */
    displayName?: string;
    /**
     * A description of this ContentType.
     */
    description?: string;
    /**
     * The base type of this ContentType.
     * Ignored for contracts; required for all other content types.
     */
    baseType?: string | null;
    /**
     * A string that is used to indicate the source of this ContentType.
     */
    readonly source?: string;
    /**
     * A value that is used to when sorting ContentType instances.
     */
    sortOrder?: number;
    /**
     * Provides a set of content types that can be created in containers of this type
     */
    mayContainTypes?: Array<string>;
    /**
     * Provides a set of media file extensions that this content type can handle.
     */
    mediaFileExtensions?: Array<string>;
    /**
     * Provides a set of composition behaviors specifying how this content type can be used within compositions.
     */
    compositionBehaviors?: Array<'sectionEnabled' | 'elementEnabled' | 'formsElementEnabled'>;
    /**
     * A timestamp indicating when this ContentType was first created.
     */
    readonly created?: Date;
    /**
     * Indicates the last time this content type was modified.
     */
    readonly lastModified?: Date;
    /**
     * The username of the user that made the latest modification to this ContentType.
     */
    readonly lastModifiedBy?: string;
    /**
     * Dictionary with all custom properties of this ContentType.
     */
    properties?: {
        [key: string]: ContentTypeProperty;
    };
};

export type ContentTypePage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<ContentType>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of items in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

/**
 * Describes a property of a ContentType in the CMS.
 */
export type ContentTypeProperty = {
    /**
     * Gets the data type for the property.
     */
    type?: 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'link' | 'richText' | 'json' | 'array' | 'component';
    /**
     * The key of the PropertyFormat that this ContentTypeProperty is an instance of.
     */
    format?: string | null;
    /**
     * The key of the content type that a property with 'type': 'component' may contain.
     */
    contentType?: string | null;
    /**
     * The display name of this ContentTypeProperty.
     */
    displayName?: string;
    /**
     * A description of this ContentTypeProperty.
     */
    description?: string;
    /**
     * Indicates if a property instance of this type should be localized for each locale
     * or if values are shared between all locales.
     */
    localized?: boolean;
    /**
     * Indicates if a property instance of this type must always be assigned a value.
     */
    required?: boolean;
    /**
     * A reference to the PropertyGroup that this ContentTypeProperty is part of.
     * If this value is empty, a group may be assigned by the system.
     */
    group?: string;
    /**
     * An value that is used to when sorting ContentTypeProperty instances.
     */
    sortOrder?: number;
    /**
     * Indicates how should this property will be indexed in the search engine.
     * If this value is not explicitly set, the property will be indexed using default indexing setting of the search engine.
     */
    indexingType?: 'disabled' | 'queryable' | 'searchable';
    /**
     * The minimum value that properties of this type should be able to contain. Value type must match the type of the property.
     */
    minimum?: number | null | number | string;
    /**
     * The minimum value that properties of this type should be able to contain. Value type must match the type of the property.
     */
    maximum?: number | null | number | string;
    /**
     * A list of possible values that properties of this type should be able to contain.
     */
    enum?: Array<EnumerationValue> | null;
    imageDescriptor?: ImageDescriptor;
    /**
     * The minimum string length that properties of this type should be able to contain.
     */
    minLength?: number | null;
    /**
     * The maximum string length that properties of this type should be able to contain.
     */
    maxLength?: number | null;
    /**
     * Regular expression pattern that limits what value that a string type property should be able to contain.
     */
    pattern?: string | null;
    /**
     * Optional minimum list length validation.
     */
    minItems?: number | null;
    /**
     * Optional maximum list length validation.
     */
    maxItems?: number | null;
    /**
     * Specifies which content types and base types these property items are allowed to contain.
     */
    allowedTypes?: Array<string>;
    /**
     * Specifies which content types and base types these property items cannot contain.
     */
    restrictedTypes?: Array<string>;
    items?: ArrayItem;
};

/**
 * Describes a setting for a display template.
 */
export type DisplaySetting = {
    /**
     * The display name of this display setting.
     */
    displayName: string;
    /**
     * The suggested editor for this display setting.
     */
    editor?: string;
    /**
     * The sort order of this display setting within the template.
     */
    sortOrder?: number;
    /**
     * The available choices for this display setting.
     */
    choices?: {
        [key: string]: DisplaySettingChoice;
    };
};

/**
 * Describes a setting for a display template.
 */
export type DisplaySettingChoice = {
    /**
     * The display name of this display setting choice.
     */
    displayName: string;
    /**
     * The sort order of this choice within the setting.
     */
    sortOrder?: number;
};

/**
 * Describes a display template that can be assigned to content.
 */
export type DisplayTemplate = {
    /**
     * The key that identifies this display template.
     */
    key?: string;
    /**
     * The display name of this display template.
     */
    displayName: string;
    /**
     * The optional node type this display template is valid for.
     */
    nodeType?: string | null;
    /**
     * The optional base type this display template is valid for.
     */
    baseType?: string | null;
    /**
     * The optional key of the content type this display template is valid for.
     */
    contentType?: string | null;
    /**
     * If this is the default display template for the associated base type, node type or content type.
     */
    isDefault?: boolean;
    /**
     * A timestamp indicating when this display template was first created.
     */
    readonly created?: Date;
    /**
     * The username of the user that created this display template.
     */
    readonly createdBy?: string;
    /**
     * A timestamp indicating when this display template was last modified.
     */
    readonly lastModified?: Date;
    /**
     * The username of the user that last modified this display template.
     */
    readonly lastModifiedBy?: string;
    /**
     * The available settings for this display template.
     */
    settings?: {
        [key: string]: DisplaySetting;
    };
};

export type DisplayTemplatePage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<DisplayTemplate>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of items in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

/**
 * Describes one value in an enumeration of possible values.
 */
export type EnumerationValue = {
    /**
     * The defined enumeration value. Value type must match the property type.
     */
    value: number | null | number | string;
    /**
     * The display name of the enumeration value.
     */
    displayName: string;
};

/**
 * Instruction for generating an alternative image from the main binary of an image content item.
 */
export type ImageDescriptor = {
    /**
     * The image width in pixels.
     */
    width?: number;
    /**
     * The image height in pixels.
     */
    height?: number;
    /**
     * Indicates if the image should be pre-generated when a new image is uploaded rather than when first requested.
     */
    pregenerated?: boolean;
};

export type ProblemDetails = {
    /**
     * A URI reference that identifies the problem type.
     */
    type?: string | null;
    /**
     * A short, human-readable summary of the problem type.
     */
    title?: string | null;
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     */
    status?: number | null;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string | null;
    /**
     * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     */
    instance?: string | null;
    /**
     * Error code that identifies the problem type.
     */
    code?: string | null;
    /**
     * An array of error details with more detailed information about the problem.
     */
    errors?: Array<{
        /**
         * A granular explanation of one specific error related to a field, header or query parameter.
         */
        detail?: string;
        /**
         * A string that may provide a hint to which field that was the source of the error.
         */
        field?: string | null;
    }> | null;
    [key: string]: unknown | string | null | string | null | number | null | string | null | string | null | string | null | Array<{
        /**
         * A granular explanation of one specific error related to a field, header or query parameter.
         */
        detail?: string;
        /**
         * A string that may provide a hint to which field that was the source of the error.
         */
        field?: string | null;
    }> | null | undefined;
};

/**
 * Represent the definition of semantic property formats for content items.
 */
export type PropertyFormat = {
    /**
     * The key that identifies this PropertyFormat.
     */
    key?: string;
    /**
     * The underlying data type used for this PropertyFormat.
     */
    dataType?: 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'link' | 'richText' | 'json' | 'array' | 'component';
    /**
     * The underlying item type used for this PropertyFormat.
     */
    itemType?: 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'link' | 'richText' | 'json' | 'array' | 'component';
    /**
     * The name and identifier of this PropertyFormat.
     */
    displayName?: string;
    /**
     * Indicates if this property format has been deleted.
     */
    readonly deleted?: boolean;
    /**
     * A timestamp indicating when this display template was first created.
     */
    readonly created?: Date;
    /**
     * The username of the user that created this display template.
     */
    readonly createdBy?: string;
    /**
     * A timestamp indicating when this display template was last modified.
     */
    readonly lastModified?: Date;
    /**
     * The username of the user that last modified this display template.
     */
    readonly lastModifiedBy?: string;
};

export type PropertyFormatPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<PropertyFormat>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of items in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

/**
 * Describes a property group of a ContentType in the CMS.
 */
export type PropertyGroup = {
    /**
     * The key that identifies this PropertyGroup.
     */
    key?: string;
    /**
     * The display name of this PropertyGroup.
     */
    displayName?: string;
    /**
     * A string that is used to indicate the source of this PropertyGroup.
     */
    readonly source?: string;
    /**
     * An value that is used to when sorting PropertyGroup instances.
     */
    sortOrder?: number;
    /**
     * A timestamp indicating when this property group was first created.
     */
    readonly created?: Date;
    /**
     * The username of the user that created this property group.
     */
    readonly createdBy?: string;
    readonly lastModified?: Date;
    /**
     * The username of the user that last modified this property group.
     */
    readonly lastModifiedBy?: string;
};

export type PropertyGroupPage = {
    /**
     * The items in this paged collection.
     */
    readonly items?: Array<PropertyGroup>;
    /**
     * The zero-based index of the current page.
     */
    readonly pageIndex?: number;
    /**
     * The number of items in each page. Not necessarily the same as the number of items in this page.
     */
    readonly pageSize?: number;
    /**
     * The estimated total number of items in the collection. May be omitted if the total item count is unknown.
     */
    readonly totalItemCount?: number;
};

/**
 * A writable implementation of an ContentType.
 */
export type ContentTypeWritable = {
    /**
     * The key that identifies this ContentType.
     */
    key?: string;
    /**
     * The display name of this ContentType.
     */
    displayName?: string;
    /**
     * A description of this ContentType.
     */
    description?: string;
    /**
     * The base type of this ContentType.
     * Ignored for contracts; required for all other content types.
     */
    baseType?: string | null;
    /**
     * A value that is used to when sorting ContentType instances.
     */
    sortOrder?: number;
    /**
     * Provides a set of content types that can be created in containers of this type
     */
    mayContainTypes?: Array<string>;
    /**
     * Provides a set of media file extensions that this content type can handle.
     */
    mediaFileExtensions?: Array<string>;
    /**
     * Provides a set of composition behaviors specifying how this content type can be used within compositions.
     */
    compositionBehaviors?: Array<'sectionEnabled' | 'elementEnabled' | 'formsElementEnabled'>;
    /**
     * Dictionary with all custom properties of this ContentType.
     */
    properties?: {
        [key: string]: ContentTypeProperty;
    };
};

export type ContentTypePageWritable = {
    [key: string]: never;
};

/**
 * Describes a display template that can be assigned to content.
 */
export type DisplayTemplateWritable = {
    /**
     * The key that identifies this display template.
     */
    key?: string;
    /**
     * The display name of this display template.
     */
    displayName: string;
    /**
     * The optional node type this display template is valid for.
     */
    nodeType?: string | null;
    /**
     * The optional base type this display template is valid for.
     */
    baseType?: string | null;
    /**
     * The optional key of the content type this display template is valid for.
     */
    contentType?: string | null;
    /**
     * If this is the default display template for the associated base type, node type or content type.
     */
    isDefault?: boolean;
    /**
     * The available settings for this display template.
     */
    settings?: {
        [key: string]: DisplaySetting;
    };
};

export type DisplayTemplatePageWritable = {
    [key: string]: never;
};

/**
 * Represent the definition of semantic property formats for content items.
 */
export type PropertyFormatWritable = {
    /**
     * The key that identifies this PropertyFormat.
     */
    key?: string;
    /**
     * The underlying data type used for this PropertyFormat.
     */
    dataType?: 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'link' | 'richText' | 'json' | 'array' | 'component';
    /**
     * The underlying item type used for this PropertyFormat.
     */
    itemType?: 'string' | 'url' | 'boolean' | 'integer' | 'float' | 'dateTime' | 'contentReference' | 'content' | 'binary' | 'link' | 'richText' | 'json' | 'array' | 'component';
    /**
     * The name and identifier of this PropertyFormat.
     */
    displayName?: string;
};

export type PropertyFormatPageWritable = {
    [key: string]: never;
};

/**
 * Describes a property group of a ContentType in the CMS.
 */
export type PropertyGroupWritable = {
    /**
     * The key that identifies this PropertyGroup.
     */
    key?: string;
    /**
     * The display name of this PropertyGroup.
     */
    displayName?: string;
    /**
     * An value that is used to when sorting PropertyGroup instances.
     */
    sortOrder?: number;
};

export type PropertyGroupPageWritable = {
    [key: string]: never;
};

export type ContentTypesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only include types that are available for creation under the provided container type
         */
        forContainerType?: string;
        /**
         * Indicates which sources should be included when listing content types.
         * Use 'DEFAULT' to include content types without a specific source.
         */
        sources?: Array<string>;
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/contenttypes';
};

export type ContentTypesListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesListError = ContentTypesListErrors[keyof ContentTypesListErrors];

export type ContentTypesListResponses = {
    /**
     * OK
     */
    200: ContentTypePage;
};

export type ContentTypesListResponse = ContentTypesListResponses[keyof ContentTypesListResponses];

export type ContentTypesCreateData = {
    /**
     * The content type that should be created or replaced.
     */
    body: ContentTypeWritable;
    path?: never;
    query?: never;
    url: '/contenttypes';
};

export type ContentTypesCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type ContentTypesCreateError = ContentTypesCreateErrors[keyof ContentTypesCreateErrors];

export type ContentTypesCreateResponses = {
    /**
     * Created
     */
    201: ContentType;
};

export type ContentTypesCreateResponse = ContentTypesCreateResponses[keyof ContentTypesCreateResponses];

export type ContentTypesDeleteData = {
    body?: never;
    headers?: {
        /**
         * If provided, the DELETE request will only be considered if the value matches the RFC7232 ETag of the current resource. Weak ETags will always be ignored.
         */
        ifMatch?: string;
        /**
         * If provided, the DELETE request will only be considered if the resource has not been modified since the provided date. This parameter will be ignored if an 'If-Match' parameter is also provided.
         */
        ifUnmodifiedSince?: string;
    };
    path: {
        /**
         * The key of the content type to delete.
         */
        key: string;
    };
    query?: never;
    url: '/contenttypes/{key}';
};

export type ContentTypesDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
    /**
     * Precondition Failed
     */
    412: ProblemDetails;
};

export type ContentTypesDeleteError = ContentTypesDeleteErrors[keyof ContentTypesDeleteErrors];

export type ContentTypesDeleteResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesDeleteResponse = ContentTypesDeleteResponses[keyof ContentTypesDeleteResponses];

export type ContentTypesGetData = {
    body?: never;
    headers?: {
        /**
         * If provided and the value matches the RFC7232 ETag of the current resource a 304 NotModified response will be returned. Weak ETags will always be ignored.
         */
        ifNoneMatch?: string;
        /**
         * If provided and the resource has not been modified since the date a 304 NotModified response will be returned. This parameter will be ignored if an 'If-None-Match' parameter is also provided.
         */
        ifModifiedSince?: string;
    };
    path: {
        /**
         * The key of the content type to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/contenttypes/{key}';
};

export type ContentTypesGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type ContentTypesGetError = ContentTypesGetErrors[keyof ContentTypesGetErrors];

export type ContentTypesGetResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesGetResponse = ContentTypesGetResponses[keyof ContentTypesGetResponses];

export type ContentTypesPatchData = {
    /**
     * The values of the content type that should be patched formatted according to RFC7396.
     */
    body: ContentTypeWritable;
    headers?: {
        /**
         * Patch the content type even though the changes might result in data loss.
         */
        cmsIgnoreDataLossWarnings?: boolean;
        /**
         * If provided, the PATCH request will only be considered if the value matches the RFC7232 ETag of the current resource. Weak ETags will always be ignored.
         */
        ifMatch?: string;
        /**
         * If provided, the PATCH request will only be considered if the resource has not been modified since the provided date. This parameter will be ignored if an 'If-Match' parameter is also provided.
         */
        ifUnmodifiedSince?: string;
    };
    path: {
        /**
         * The key of the content type to patch.
         */
        key: string;
    };
    query?: never;
    url: '/contenttypes/{key}';
};

export type ContentTypesPatchErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
    /**
     * Precondition Failed
     */
    412: ProblemDetails;
};

export type ContentTypesPatchError = ContentTypesPatchErrors[keyof ContentTypesPatchErrors];

export type ContentTypesPatchResponses = {
    /**
     * OK
     */
    200: ContentType;
};

export type ContentTypesPatchResponse = ContentTypesPatchResponses[keyof ContentTypesPatchResponses];

export type DisplayTemplatesListData = {
    body?: never;
    path?: never;
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/displaytemplates';
};

export type DisplayTemplatesListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesListError = DisplayTemplatesListErrors[keyof DisplayTemplatesListErrors];

export type DisplayTemplatesListResponses = {
    /**
     * OK
     */
    200: DisplayTemplatePage;
};

export type DisplayTemplatesListResponse = DisplayTemplatesListResponses[keyof DisplayTemplatesListResponses];

export type DisplayTemplatesCreateData = {
    /**
     * The display template that should be created.
     */
    body: DisplayTemplateWritable;
    path?: never;
    query?: never;
    url: '/displaytemplates';
};

export type DisplayTemplatesCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type DisplayTemplatesCreateError = DisplayTemplatesCreateErrors[keyof DisplayTemplatesCreateErrors];

export type DisplayTemplatesCreateResponses = {
    /**
     * Created
     */
    201: DisplayTemplate;
};

export type DisplayTemplatesCreateResponse = DisplayTemplatesCreateResponses[keyof DisplayTemplatesCreateResponses];

export type DisplayTemplatesDeleteData = {
    body?: never;
    headers?: {
        /**
         * If provided, the DELETE request will only be considered if the value matches the RFC7232 ETag of the current resource. Weak ETags will always be ignored.
         */
        ifMatch?: string;
        /**
         * If provided, the DELETE request will only be considered if the resource has not been modified since the provided date. This parameter will be ignored if an 'If-Match' parameter is also provided.
         */
        ifUnmodifiedSince?: string;
    };
    path: {
        /**
         * The key of the display template to delete.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
    /**
     * Precondition Failed
     */
    412: ProblemDetails;
};

export type DisplayTemplatesDeleteError = DisplayTemplatesDeleteErrors[keyof DisplayTemplatesDeleteErrors];

export type DisplayTemplatesDeleteResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesDeleteResponse = DisplayTemplatesDeleteResponses[keyof DisplayTemplatesDeleteResponses];

export type DisplayTemplatesGetData = {
    body?: never;
    headers?: {
        /**
         * If provided and the value matches the RFC7232 ETag of the current resource a 304 NotModified response will be returned. Weak ETags will always be ignored.
         */
        ifNoneMatch?: string;
        /**
         * If provided and the resource has not been modified since the date a 304 NotModified response will be returned. This parameter will be ignored if an 'If-None-Match' parameter is also provided.
         */
        ifModifiedSince?: string;
    };
    path: {
        /**
         * The key of the display template to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type DisplayTemplatesGetError = DisplayTemplatesGetErrors[keyof DisplayTemplatesGetErrors];

export type DisplayTemplatesGetResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesGetResponse = DisplayTemplatesGetResponses[keyof DisplayTemplatesGetResponses];

export type DisplayTemplatesPatchData = {
    /**
     * The values of the display template that should be patched formatted according to RFC7396.
     */
    body: DisplayTemplateWritable;
    headers?: {
        /**
         * If provided, the PATCH request will only be considered if the value matches the RFC7232 ETag of the current resource. Weak ETags will always be ignored.
         */
        ifMatch?: string;
        /**
         * If provided, the PATCH request will only be considered if the resource has not been modified since the provided date. This parameter will be ignored if an 'If-Match' parameter is also provided.
         */
        ifUnmodifiedSince?: string;
    };
    path: {
        /**
         * The key of the display template to patch.
         */
        key: string;
    };
    query?: never;
    url: '/displaytemplates/{key}';
};

export type DisplayTemplatesPatchErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
    /**
     * Precondition Failed
     */
    412: ProblemDetails;
};

export type DisplayTemplatesPatchError = DisplayTemplatesPatchErrors[keyof DisplayTemplatesPatchErrors];

export type DisplayTemplatesPatchResponses = {
    /**
     * OK
     */
    200: DisplayTemplate;
};

export type DisplayTemplatesPatchResponse = DisplayTemplatesPatchResponses[keyof DisplayTemplatesPatchResponses];

export type PropertyFormatsListData = {
    body?: never;
    path?: never;
    query?: {
        pageIndex?: number;
        pageSize?: number;
    };
    url: '/propertyformats';
};

export type PropertyFormatsListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyFormatsListError = PropertyFormatsListErrors[keyof PropertyFormatsListErrors];

export type PropertyFormatsListResponses = {
    /**
     * OK
     */
    200: PropertyFormatPage;
};

export type PropertyFormatsListResponse = PropertyFormatsListResponses[keyof PropertyFormatsListResponses];

export type PropertyFormatsGetData = {
    body?: never;
    headers?: {
        /**
         * If provided and the value matches the RFC7232 ETag of the current resource a 304 NotModified response will be returned. Weak ETags will always be ignored.
         */
        ifNoneMatch?: string;
        /**
         * If provided and the resource has not been modified since the date a 304 NotModified response will be returned. This parameter will be ignored if an 'If-None-Match' parameter is also provided.
         */
        ifModifiedSince?: string;
    };
    path: {
        /**
         * The key of the property format to retrieve.
         */
        key: string;
    };
    query?: {
        /**
         * Indicates that a deleted property format may be returned.
         */
        allowDeleted?: boolean;
    };
    url: '/propertyformats/{key}';
};

export type PropertyFormatsGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type PropertyFormatsGetError = PropertyFormatsGetErrors[keyof PropertyFormatsGetErrors];

export type PropertyFormatsGetResponses = {
    /**
     * OK
     */
    200: PropertyFormat;
};

export type PropertyFormatsGetResponse = PropertyFormatsGetResponses[keyof PropertyFormatsGetResponses];

export type PropertyGroupsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Indicates which property groups sources should be listed.
         * Use 'DEFAULT' to include groups without a specific sources.
         */
        sources?: Array<string>;
    };
    url: '/propertygroups';
};

export type PropertyGroupsListErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsListError = PropertyGroupsListErrors[keyof PropertyGroupsListErrors];

export type PropertyGroupsListResponses = {
    /**
     * OK
     */
    200: PropertyGroupPage;
};

export type PropertyGroupsListResponse = PropertyGroupsListResponses[keyof PropertyGroupsListResponses];

export type PropertyGroupsCreateData = {
    /**
     * The property group that should be created.
     */
    body: PropertyGroupWritable;
    path?: never;
    query?: never;
    url: '/propertygroups';
};

export type PropertyGroupsCreateErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
};

export type PropertyGroupsCreateError = PropertyGroupsCreateErrors[keyof PropertyGroupsCreateErrors];

export type PropertyGroupsCreateResponses = {
    /**
     * Created
     */
    201: PropertyGroup;
};

export type PropertyGroupsCreateResponse = PropertyGroupsCreateResponses[keyof PropertyGroupsCreateResponses];

export type PropertyGroupsDeleteData = {
    body?: never;
    headers?: {
        /**
         * If provided, the DELETE request will only be considered if the value matches the RFC7232 ETag of the current resource. Weak ETags will always be ignored.
         */
        ifMatch?: string;
        /**
         * If provided, the DELETE request will only be considered if the resource has not been modified since the provided date. This parameter will be ignored if an 'If-Match' parameter is also provided.
         */
        ifUnmodifiedSince?: string;
    };
    path: {
        /**
         * The key of the property group to delete.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsDeleteErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
    /**
     * Precondition Failed
     */
    412: ProblemDetails;
};

export type PropertyGroupsDeleteError = PropertyGroupsDeleteErrors[keyof PropertyGroupsDeleteErrors];

export type PropertyGroupsDeleteResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsDeleteResponse = PropertyGroupsDeleteResponses[keyof PropertyGroupsDeleteResponses];

export type PropertyGroupsGetData = {
    body?: never;
    headers?: {
        /**
         * If provided and the value matches the RFC7232 ETag of the current resource a 304 NotModified response will be returned. Weak ETags will always be ignored.
         */
        ifNoneMatch?: string;
        /**
         * If provided and the resource has not been modified since the date a 304 NotModified response will be returned. This parameter will be ignored if an 'If-None-Match' parameter is also provided.
         */
        ifModifiedSince?: string;
    };
    path: {
        /**
         * The key of the property group to retrieve.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsGetErrors = {
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type PropertyGroupsGetError = PropertyGroupsGetErrors[keyof PropertyGroupsGetErrors];

export type PropertyGroupsGetResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsGetResponse = PropertyGroupsGetResponses[keyof PropertyGroupsGetResponses];

export type PropertyGroupsPatchData = {
    /**
     * The values of the property group that should be patched formatted according to RFC7396.
     */
    body: PropertyGroupWritable;
    headers?: {
        /**
         * If provided, the PATCH request will only be considered if the value matches the RFC7232 ETag of the current resource. Weak ETags will always be ignored.
         */
        ifMatch?: string;
        /**
         * If provided, the PATCH request will only be considered if the resource has not been modified since the provided date. This parameter will be ignored if an 'If-Match' parameter is also provided.
         */
        ifUnmodifiedSince?: string;
    };
    path: {
        /**
         * The key of the property group to patch.
         */
        key: string;
    };
    query?: never;
    url: '/propertygroups/{key}';
};

export type PropertyGroupsPatchErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Not Found
     */
    404: ProblemDetails;
    /**
     * Precondition Failed
     */
    412: ProblemDetails;
};

export type PropertyGroupsPatchError = PropertyGroupsPatchErrors[keyof PropertyGroupsPatchErrors];

export type PropertyGroupsPatchResponses = {
    /**
     * OK
     */
    200: PropertyGroup;
};

export type PropertyGroupsPatchResponse = PropertyGroupsPatchResponses[keyof PropertyGroupsPatchResponses];
